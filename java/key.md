# 关键字
#### final
```text
修饰类：这个类不能被继承。
方法：把方法锁住 防止继承类修改。
变量：如果是基本数据类型 数值初始化后不能修改，如果是引用类型 初始化后不能指向另一个对象。
```

#### static
```text
作用于成员变量，用来表示只保存一份副本
```

#### 对比final  finalize  finally
```text
final : 修饰符，能修饰变量、方法和类。 初始化后不能被修改。
finalize ： 方法，对象被回收之前调用的方法。
finally ： 关键字，与try catch 一起进行异常处理，finally块一定会被执行，无论try块里是否发生异常。
```

#### switch
```text
当进行case判断时，JVM会自动从上到下扫描，寻找匹配的case：
    未找到-执行默认的case
    当每个case都不存在break时，JVM并不会顺序输出每个case对应的返回值，而是继续匹配，匹配不成功，则返回默认case。
    当每个case都不存在break时，匹配成功后，从当前case开始，依次返回后续所有case的返回值。
    若当前匹配成功的case不存在break，则从当前case开始，依次返回后续case的返回值，直到遇到break，跳出判断。
```

```text
// swithc-case 格式
// 变量类型：int/short/char/byte/enum
switch(变量){
    case 变量值1：
        // ;
        break;
    case 变量值2:
        // ;
        break;
        ......
   case default:
        // ;
        break;
}
```

#### volatile
- 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰以后，就具备了两次语义：
    - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。但不能保证原子性。
    - 禁止进行指令重排序。
    
- volatile的原理和实现机制。下面这段话摘自《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”。

- lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    - 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    - 它会强制将对缓存的修改操作立即写入主存；
    - 如果是写操作，它会导致其他CPU中对应的缓存行无效
```


